# 公众号引导关注和消息推送测试方案

## 1. 测试目标

- ✅ 测试用户关注状态检查
- ✅ 测试公众号关注引导功能
- ✅ 测试模板消息推送
- ✅ 验证整个流程的完整性

## 2. 后端测试接口实现

### 2.1 创建测试控制器

```java
@RestController
@RequestMapping("/test")
@Slf4j
public class WechatTestController {
    
    @Autowired
    private WechatMessageService wechatMessageService;
    
    @Autowired
    private AppointmentService appointmentService;
    
    /**
     * 测试检查用户关注状态
     */
    @GetMapping("/checkSubscription")
    public ResponseEntity<Result> checkSubscription(@RequestParam String openid) {
        try {
            boolean isSubscribed = wechatMessageService.checkUserSubscription(openid);
            
            Result result = new Result();
            result.setCode("0");
            result.setData(isSubscribed);
            result.setMsg(isSubscribed ? "用户已关注公众号" : "用户未关注公众号");
            
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            log.error("检查用户关注状态失败", e);
            Result result = new Result();
            result.setCode("1");
            result.setMsg("检查失败：" + e.getMessage());
            return ResponseEntity.ok(result);
        }
    }
    
    /**
     * 测试发送模板消息
     */
    @PostMapping("/sendTimeoutMessage")
    public ResponseEntity<Result> sendTimeoutMessage(@RequestBody TestMessageRequest request) {
        try {
            // 检查用户是否关注
            boolean isSubscribed = wechatMessageService.checkUserSubscription(request.getOpenid());
            if (!isSubscribed) {
                Result result = new Result();
                result.setCode("1");
                result.setMsg("用户未关注公众号，无法发送模板消息");
                return ResponseEntity.ok(result);
            }
            
            // 构造测试数据
            Date now = new Date();
            Date enterTime = new Date(now.getTime() - 60 * 60 * 1000); // 1小时前进场
            Date expectedLeaveTime = new Date(now.getTime() + 15 * 60 * 1000); // 15分钟后超时
            
            // 发送测试消息
            boolean success = wechatMessageService.sendTimeoutWarningMessage(
                request.getOpenid(),
                request.getPlateNumber(),
                request.getYardName(),
                expectedLeaveTime,
                enterTime
            );
            
            Result result = new Result();
            result.setCode(success ? "0" : "1");
            result.setData(success);
            result.setMsg(success ? "模板消息发送成功" : "模板消息发送失败");
            
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            log.error("发送测试消息失败", e);
            Result result = new Result();
            result.setCode("1");
            result.setMsg("发送失败：" + e.getMessage());
            return ResponseEntity.ok(result);
        }
    }
    
    /**
     * 模拟预约接口（用于测试引导关注）
     */
    @PostMapping("/mockAppointment")
    public ResponseEntity<Result> mockAppointment(@RequestBody MockAppointmentRequest request) {
        try {
            Result result = new Result();
            result.setCode("0");
            result.setMsg("预约成功！");
            
            // 检查用户是否关注公众号
            if (StringUtils.isNotEmpty(request.getOpenid())) {
                boolean isSubscribed = wechatMessageService.checkUserSubscription(request.getOpenid());
                if (!isSubscribed) {
                    result.setMsg("预约成功！为了及时接收停车提醒，建议您关注我们的公众号。");
                    result.setCode("NEED_SUBSCRIBE");
                    
                    // 返回公众号二维码信息
                    Map<String, Object> extraData = new HashMap<>();
                    extraData.put("qrcode_url", "https://your-domain.com/qrcode.jpg");
                    extraData.put("subscribe_tip", "扫描二维码关注公众号，及时接收停车提醒");
                    extraData.put("is_subscribed", false);
                    result.setExtra(extraData);
                } else {
                    Map<String, Object> extraData = new HashMap<>();
                    extraData.put("is_subscribed", true);
                    result.setExtra(extraData);
                }
            }
            
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            log.error("模拟预约失败", e);
            Result result = new Result();
            result.setCode("1");
            result.setMsg("预约失败：" + e.getMessage());
            return ResponseEntity.ok(result);
        }
    }
}

/**
 * 测试消息请求参数
 */
@Data
class TestMessageRequest {
    private String openid;
    private String plateNumber;
    private String yardName;
}

/**
 * 模拟预约请求参数
 */
@Data
class MockAppointmentRequest {
    private String openid;
    private String plateNumber;
    private String yardName;
}
```

## 3. 小程序端测试页面

### 3.1 创建测试页面 `pages/test/wechat-test.vue`

```vue
<template>
	<view class="container">
		<view class="header">
			<text class="title">公众号功能测试</text>
		</view>
		
		<!-- 用户信息显示 -->
		<view class="info-section">
			<view class="info-item">
				<text class="label">OpenID:</text>
				<text class="value">{{ userInfo.openid || '未获取' }}</text>
			</view>
			<view class="info-item">
				<text class="label">关注状态:</text>
				<text class="value" :class="subscribeStatus === true ? 'success' : 'error'">
					{{ subscribeStatusText }}
				</text>
			</view>
		</view>
		
		<!-- 操作按钮 -->
		<view class="action-section">
			<button class="btn primary" @click="getUserInfo">获取用户信息</button>
			<button class="btn" @click="checkSubscription" :disabled="!userInfo.openid">
				检查关注状态
			</button>
			<button class="btn" @click="mockAppointment" :disabled="!userInfo.openid">
				模拟预约（测试引导）
			</button>
			<button class="btn" @click="sendTestMessage" :disabled="!userInfo.openid">
				发送测试消息
			</button>
		</view>
		
		<!-- 测试参数设置 -->
		<view class="form-section">
			<view class="form-title">测试参数</view>
			<view class="form-item">
				<text class="form-label">车牌号:</text>
				<input class="form-input" v-model="testParams.plateNumber" placeholder="请输入车牌号" />
			</view>
			<view class="form-item">
				<text class="form-label">停车场:</text>
				<input class="form-input" v-model="testParams.yardName" placeholder="请输入停车场名称" />
			</view>
		</view>
		
		<!-- 日志显示 -->
		<view class="log-section">
			<view class="log-title">操作日志</view>
			<scroll-view class="log-content" scroll-y>
				<view class="log-item" v-for="(log, index) in logs" :key="index">
					<text class="log-time">{{ log.time }}</text>
					<text class="log-text" :class="log.type">{{ log.message }}</text>
				</view>
			</scroll-view>
		</view>
	</view>
</template>

<script>
export default {
	data() {
		return {
			userInfo: {
				openid: ''
			},
			subscribeStatus: null,
			testParams: {
				plateNumber: '粤B888888',
				yardName: '测试停车场'
			},
			logs: []
		}
	},
	computed: {
		subscribeStatusText() {
			if (this.subscribeStatus === null) return '未检查';
			return this.subscribeStatus ? '已关注' : '未关注';
		}
	},
	onLoad() {
		this.addLog('页面加载完成', 'info');
	},
	methods: {
		/**
		 * 获取用户信息
		 */
		async getUserInfo() {
			try {
				this.addLog('开始获取用户信息...', 'info');
				
				// 先尝试获取已有的openid
				const loginRes = await this.$api.getUserInfo();
				if (loginRes && loginRes.openid) {
					this.userInfo.openid = loginRes.openid;
					this.addLog(`获取用户信息成功: ${loginRes.openid}`, 'success');
					return;
				}
				
				// 如果没有，则进行登录
				const code = await this.getWxCode();
				const result = await this.$api.wxLogin({ code });
				
				if (result && result.openid) {
					this.userInfo.openid = result.openid;
					this.addLog(`登录成功，OpenID: ${result.openid}`, 'success');
				} else {
					this.addLog('获取OpenID失败', 'error');
				}
			} catch (error) {
				console.error('获取用户信息失败:', error);
				this.addLog(`获取用户信息失败: ${error.message}`, 'error');
			}
		},
		
		/**
		 * 获取微信code
		 */
		getWxCode() {
			return new Promise((resolve, reject) => {
				uni.login({
					provider: 'weixin',
					success: (res) => {
						resolve(res.code);
					},
					fail: (error) => {
						reject(error);
					}
				});
			});
		},
		
		/**
		 * 检查关注状态
		 */
		async checkSubscription() {
			try {
				this.addLog('检查用户关注状态...', 'info');
				
				const response = await uni.request({
					url: this.$config.baseUrl + '/test/checkSubscription',
					method: 'GET',
					data: {
						openid: this.userInfo.openid
					}
				});
				
				const result = response[1].data;
				this.subscribeStatus = result.data;
				this.addLog(result.msg, result.code === '0' ? 'success' : 'error');
				
			} catch (error) {
				console.error('检查关注状态失败:', error);
				this.addLog(`检查关注状态失败: ${error.message}`, 'error');
			}
		},
		
		/**
		 * 模拟预约（测试引导关注）
		 */
		async mockAppointment() {
			try {
				this.addLog('模拟预约中...', 'info');
				
				const response = await uni.request({
					url: this.$config.baseUrl + '/test/mockAppointment',
					method: 'POST',
					data: {
						openid: this.userInfo.openid,
						plateNumber: this.testParams.plateNumber,
						yardName: this.testParams.yardName
					}
				});
				
				const result = response[1].data;
				this.addLog(result.msg, 'info');
				
				// 如果需要引导关注
				if (result.code === 'NEED_SUBSCRIBE') {
					this.showSubscribeGuide(result.extra);
				} else if (result.extra && result.extra.is_subscribed) {
					this.addLog('用户已关注公众号，无需引导', 'success');
				}
				
			} catch (error) {
				console.error('模拟预约失败:', error);
				this.addLog(`模拟预约失败: ${error.message}`, 'error');
			}
		},
		
		/**
		 * 显示关注引导
		 */
		showSubscribeGuide(extraData) {
			this.addLog('显示关注引导弹窗', 'info');
			
			uni.showModal({
				title: '温馨提示',
				content: '为了及时接收停车超时提醒，建议您关注我们的公众号',
				confirmText: '去关注',
				cancelText: '稍后',
				success: (modalRes) => {
					if (modalRes.confirm) {
						this.addLog('用户选择去关注公众号', 'info');
						// 这里可以显示二维码或跳转到关注页面
						this.showQRCode(extraData.qrcode_url);
					} else {
						this.addLog('用户选择稍后关注', 'info');
					}
				}
			});
		},
		
		/**
		 * 显示二维码
		 */
		showQRCode(qrcodeUrl) {
			this.addLog('显示公众号二维码', 'info');
			// 这里可以实现显示二维码的逻辑
			// 比如打开一个新页面或者显示图片
		},
		
		/**
		 * 发送测试消息
		 */
		async sendTestMessage() {
			try {
				this.addLog('发送测试消息...', 'info');
				
				const response = await uni.request({
					url: this.$config.baseUrl + '/test/sendTimeoutMessage',
					method: 'POST',
					data: {
						openid: this.userInfo.openid,
						plateNumber: this.testParams.plateNumber,
						yardName: this.testParams.yardName
					}
				});
				
				const result = response[1].data;
				this.addLog(result.msg, result.code === '0' ? 'success' : 'error');
				
				if (result.code === '0') {
					this.addLog('请检查微信公众号是否收到消息', 'info');
				}
				
			} catch (error) {
				console.error('发送测试消息失败:', error);
				this.addLog(`发送测试消息失败: ${error.message}`, 'error');
			}
		},
		
		/**
		 * 添加日志
		 */
		addLog(message, type = 'info') {
			const now = new Date();
			const timeStr = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;
			
			this.logs.unshift({
				time: timeStr,
				message: message,
				type: type
			});
			
			// 限制日志数量
			if (this.logs.length > 50) {
				this.logs = this.logs.slice(0, 50);
			}
		}
	}
}
</script>

<style scoped>
.container {
	padding: 20rpx;
	background-color: #f5f5f5;
	min-height: 100vh;
}

.header {
	text-align: center;
	margin-bottom: 30rpx;
}

.title {
	font-size: 36rpx;
	font-weight: bold;
	color: #333;
}

.info-section {
	background: white;
	border-radius: 10rpx;
	padding: 30rpx;
	margin-bottom: 30rpx;
}

.info-item {
	display: flex;
	justify-content: space-between;
	margin-bottom: 20rpx;
}

.label {
	color: #666;
	font-size: 28rpx;
}

.value {
	color: #333;
	font-size: 28rpx;
	font-weight: bold;
}

.success {
	color: #4CAF50;
}

.error {
	color: #F44336;
}

.action-section {
	margin-bottom: 30rpx;
}

.btn {
	width: 100%;
	margin-bottom: 20rpx;
	padding: 25rpx;
	border-radius: 10rpx;
	font-size: 28rpx;
	background: white;
	color: #333;
}

.btn.primary {
	background: #007AFF;
	color: white;
}

.btn:disabled {
	background: #ccc;
	color: #999;
}

.form-section {
	background: white;
	border-radius: 10rpx;
	padding: 30rpx;
	margin-bottom: 30rpx;
}

.form-title {
	font-size: 32rpx;
	font-weight: bold;
	color: #333;
	margin-bottom: 20rpx;
}

.form-item {
	display: flex;
	align-items: center;
	margin-bottom: 20rpx;
}

.form-label {
	width: 150rpx;
	color: #666;
	font-size: 28rpx;
}

.form-input {
	flex: 1;
	padding: 20rpx;
	border: 1px solid #ddd;
	border-radius: 5rpx;
	font-size: 28rpx;
}

.log-section {
	background: white;
	border-radius: 10rpx;
	padding: 30rpx;
	height: 600rpx;
}

.log-title {
	font-size: 32rpx;
	font-weight: bold;
	color: #333;
	margin-bottom: 20rpx;
}

.log-content {
	height: 500rpx;
}

.log-item {
	display: flex;
	margin-bottom: 10rpx;
	padding: 10rpx;
	border-radius: 5rpx;
	background: #f9f9f9;
}

.log-time {
	width: 150rpx;
	color: #999;
	font-size: 24rpx;
}

.log-text {
	flex: 1;
	font-size: 26rpx;
}

.log-text.info {
	color: #666;
}

.log-text.success {
	color: #4CAF50;
}

.log-text.error {
	color: #F44336;
}
</style>
```

### 3.2 在 `pages.json` 中添加测试页面

```json
{
  "pages": [
    // ... 其他页面
    {
      "path": "pages/test/wechat-test",
      "style": {
        "navigationBarTitleText": "公众号功能测试"
      }
    }
  ]
}
```

## 4. 测试步骤

### 4.1 前置准备

1. **配置微信公众号**
   ```yaml
   # application.yml
   wechat:
     appid: wx_your_appid
     secret: your_app_secret
     timeout:
       template:
         id: 45414
   ```

2. **部署后端代码**
   - 确保 `WechatTestController` 已部署
   - 确保 `WechatMessageService` 正常工作

### 4.2 测试流程

1. **打开测试页面**
   - 在小程序中打开 `pages/test/wechat-test` 页面

2. **获取用户信息**
   - 点击"获取用户信息"按钮
   - 确认获取到了有效的 OpenID

3. **检查关注状态**
   - 点击"检查关注状态"按钮
   - 查看用户是否已关注公众号

4. **测试引导关注**
   - 点击"模拟预约（测试引导）"按钮
   - 如果未关注，应该弹出引导关注的提示

5. **测试消息推送**
   - 点击"发送测试消息"按钮
   - 如果已关注，应该收到微信模板消息
   - 如果未关注，会提示无法发送

### 4.3 预期结果

1. **已关注用户**：
   - 检查状态显示"已关注"
   - 模拟预约无引导提示
   - 能正常接收测试消息

2. **未关注用户**：
   - 检查状态显示"未关注"
   - 模拟预约显示引导关注弹窗
   - 无法接收测试消息

## 5. 调试建议

### 5.1 常见问题

1. **获取OpenID失败**
   - 检查小程序登录逻辑
   - 确认微信开发者工具中的用户信息

2. **关注状态检查失败**
   - 检查微信公众号AppID和Secret配置
   - 确认AccessToken获取正常

3. **模板消息发送失败**
   - 检查模板ID是否正确（45414）
   - 确认用户确实关注了公众号
   - 查看后端日志中的错误信息

### 5.2 日志查看

- 小程序端：查看页面下方的操作日志
- 后端：查看控制台日志和数据库日志表

这个测试方案可以帮您完整验证公众号引导关注和消息推送的所有功能。您可以先实现这个测试页面，然后逐步测试各个功能点。 